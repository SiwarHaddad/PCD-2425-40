import { Component, OnInit } from "@angular/core"
import { FormBuilder, FormGroup, ReactiveFormsModule, Validators } from "@angular/forms"
import { ActivatedRoute, Router, RouterLink } from "@angular/router"
import { ImageService } from "../../../core/services/image.service"
import { AnalysisService } from "../../../core/services/analysis.service"
import { ToastrService } from "ngx-toastr"
import { ImageDetails } from "../../../core/models/image.model"
import { DatePipe, NgClass, NgForOf, NgIf, PercentPipe } from "@angular/common"
import { LoadingSpinnerComponent } from "../../../shared/components/loading-spinner/loading-spinner.component"
import { catchError, finalize, map, tap } from "rxjs/operators"
import { Observable, of } from "rxjs"
import { AuthService } from "../../../core/services/auth.service"
import { UserService } from '../../../core/services/user.service';
import { User } from '../../../core/models/user.model';
import { AnalysisDto } from '../../../core/models/report.model';
import { ReportService } from '../../../core/services/report.service';
import { ReportResponse, ReportType } from '../../../core/models/report.model';

@Component({
  selector: "app-image-analyze",
  templateUrl: "./image-analyze.component.html",
  styleUrls: ["./image-analyze.component.scss"],
  imports: [RouterLink, ReactiveFormsModule, NgIf, NgForOf, DatePipe, NgClass, PercentPipe, LoadingSpinnerComponent],
  standalone: true,
})
export class ImageAnalyzeComponent implements OnInit {
  imageId = ""
  analysisId = "" // To track the selected analysis ID
  image: ImageDetails | null = null
  currentAnalysis: AnalysisDto | null = null
  loading = true
  analyzing = false
  analysisForm: FormGroup
  errorMessage = ""
  name: string;
  autoGeneratedReports: ReportResponse[] = [];
  loadingReports = false;

  // For template use to check report types
  reportTypes = ReportType;

  constructor(
    private route: ActivatedRoute,
    private router: Router,
    private authService: AuthService,
    private analysisService: AnalysisService,
    private imageService: ImageService,
    private userService: UserService,
    private reportService: ReportService,
    private fb: FormBuilder,
    private toastr: ToastrService,
  ) {
    this.analysisForm = this.fb.group({
      userId: ["", Validators.required]
    })
  }

  ngOnInit(): void {
    this.route.paramMap.subscribe(params => {
      this.imageId = params.get("id") || "";

      if (this.imageId) {
        this.route.queryParamMap.subscribe(queryParams => {
          this.analysisId = this.imageId
          this.loadImageDetails();
          this.loadAnalysisById(this.analysisId);
          this.loadAutoGeneratedReports(this.imageId);
        });
      } else {
        this.toastr.error("Image ID is missing", "Error");
        this.router.navigate(["/images"]);
      }
    });
  }

  loadAutoGeneratedReports(imageId: string): void {
    this.loadingReports = true;
    this.reportService.getAutoGenerated(imageId)
      .pipe(
        tap((reports: ReportResponse[]) => {
          if (reports.length > 3) {
            this.autoGeneratedReports = reports.slice(0,2); // Take the first 2 items
          } else {
            this.autoGeneratedReports = reports; // Use the full array
          }
        }),
        catchError((error) => {
          console.error('Failed to load auto-generated reports:', error);
          return of([]);
        }),
        finalize(() => {
          this.loadingReports = false;
        })
      )
      .subscribe();
  }

  loadImageDetails(): void {
    this.loading = true;
    this.errorMessage = "";

    this.imageService
      .getImage(this.imageId)
      .pipe(
        tap((image: ImageDetails) => {
          this.image = image;

          // Now check if we need to load a specific analysis
          if (this.analysisId) {
            // Load the specific analysis result
            this.loadAnalysisById(this.analysisId);
          } else if (image.analysisResults?.length > 0) {
            // If no specific analysis was requested, use the most recent one
            this.currentAnalysis = image.analysisResults[0];
            this.updateUrlWithAnalysisId(this.getAnalysisId(this.currentAnalysis));
          }
        }),
        catchError((error) => {
          this.toastr.error("Failed to load image details", "Error");
          this.errorMessage = "Failed to load image details";
          this.router.navigate(["/images"]);
          return of(null);
        }),
        finalize(() => {
          this.loading = false;
        }),
      )
      .subscribe();
  }

  loadAnalysisById(analysisId: string): void {
    this.analysisService
      .getAnalysisResult(analysisId)
      .pipe(
        tap((result: AnalysisDto) => {
          this.currentAnalysis = result;
          this.getUserName(result.analyzedBy).subscribe((name) => {
            this.name = name
          })
        }),
        catchError((error) => {
          console.error("Failed to load analysis result:", error);
          return of(null);
        })
      )
      .subscribe();
  }

  // Helper method to get the analysis ID safely, handling both property names
  private getAnalysisId(analysis: AnalysisDto): string {
    return analysis.id  || '';
  }

  analyzeImage(): void {
    this.analyzing = true;
    this.errorMessage = "";
    const userId = this.getCurrentUserId();

    this.analysisService
      .runAnalysis(this.imageId, userId)
      .pipe(
        tap((result: AnalysisDto) => {
          this.toastr.success("Analysis completed successfully", "Success");
          this.currentAnalysis = result;

          // Add the new analysis to the image's analysis results
          if (this.image) {
            if (!this.image.analysisResults) {
              this.image.analysisResults = [];
            }
            this.image.analysisResults.unshift(result);
          }

          // Update the URL with the new analysis ID
          this.updateUrlWithAnalysisId(this.getAnalysisId(result));

          // Reload auto-generated reports after new analysis
          this.loadAutoGeneratedReports(this.imageId);
        }),
        catchError((error) => {
          let errorMessage = "Failed to analyze image";

          if (error.status === 0) {
            errorMessage = "Cannot connect to server. Please try again later.";
          } else if (error.error?.message) {
            errorMessage = error.error.message;
          }

          this.toastr.error(errorMessage, "Error");
          this.errorMessage = errorMessage;
          return of(null);
        }),
        finalize(() => {
          this.analyzing = false;
        })
      )
      .subscribe();
  }

  // Get the current user ID
  private getCurrentUserId(): string {
    return this.authService.getCurrentUser()?.id || 'unknown';
  }

  selectAnalysis(analysis: AnalysisDto): void {
    this.currentAnalysis = analysis;
    // Update the URL when a different analysis is selected
    this.updateUrlWithAnalysisId(this.getAnalysisId(analysis));
  }

  // Helper method to update the URL with the analysis ID
  private updateUrlWithAnalysisId(analysisId: string): void {
    if (!analysisId) {
      console.warn("Attempted to update URL with empty analysis ID");
      return;
    }

    this.router.navigate([], {
      relativeTo: this.route,
      queryParams: { analysisId: analysisId },
      queryParamsHandling: 'merge', // Keep other query params
      replaceUrl: true // Don't create a new browser history entry
    });
    this.analysisId = analysisId;
  }

  getUserName(userId: string): Observable<string> {
    return this.userService.getUserById(userId).pipe(
      map((user: User) => `${user.firstname} ${user.lastname}`),
      catchError(() => of('Unknown User'))
    );
  }

  getDetailedResults(): { key: string; value: any }[] {
    if (!this.currentAnalysis || !this.currentAnalysis.detailedResults) {
      return []
    }

    return Object.entries(this.currentAnalysis.detailedResults).map(([key, value]) => ({
      key: key.replace(/([A-Z])/g, " $1").replace(/^./, (str) => str.toUpperCase()),
      value: typeof value === "number" && key.toLowerCase().includes("score") ? (value * 100).toFixed(2) + "%" : value,
    }))
  }

  // Get formatted date for reports
  getFormattedDate(dateString: string): string {
    const date = new Date(dateString);
    return date.toLocaleString();
  }

  protected readonly window = window;
}
